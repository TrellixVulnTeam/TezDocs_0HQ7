import * as fs from 'fs';
import { existsSync } from 'fs';
import * as path from 'path';

const CACHE_PATH = "node_modules/.cache/tez";
const DEFAULT_STRAPI_URL = "http://localhost:1337";

function createPath(pathToCreate) {
  var isNotExits = false;
  pathToCreate.split(path.sep).reduce((prevPath, folder) => {
    const currentPath = path.join(prevPath, folder, path.sep);
    isNotExits = !fs.existsSync(currentPath);
    if (isNotExits) {
      fs.mkdirSync(currentPath);
    }
    return currentPath;
  }, "");
  return isNotExits;
}

function getPath(pathCollection, isCreateFolder = false) {
  const currentPath = path.join(...pathCollection);
  if (isCreateFolder)
    createPath(currentPath);
  return currentPath;
}

function removePath(path) {
  if (fs.existsSync(path))
    fs.rmSync(path, { recursive: true, force: true });
}

function deleteFile(path) {
  if (fs.existsSync(path))
    fs.unlinkSync(path);
}

class CommonPathResolver {
  get indexHtmlPath() {
    return getPath([commonContainer.buildOptions.rootDir, "index.html"], false);
  }
  get rootPath() {
    return getPath([commonContainer.buildOptions.rootDir], true);
  }
  get publicFolder() {
    return getPath([commonContainer.buildOptions.rootDir, "public"], true);
  }
  get cachePath() {
    return getPath([commonContainer.buildOptions.rootDir, CACHE_PATH], true);
  }
  get depsPath() {
    return getPath([this.cachePath, "deps"], true);
  }
  get distPath() {
    return getPath([this.rootPath, "dist"], false);
  }
  get clientEnvPath() {
    return getPath([this.cachePath, "client-env.ts"]);
  }
  get tezTsPath() {
    return getPath([this.cachePath, "tez.ts"]);
  }
  get serverEnvPath() {
    return getPath([this.cachePath, "server-env.ts"]);
  }
  get addLibPath() {
    return getPath([commonContainer.buildOptions.rootDir, "add-lib.ts"], false);
  }
  get routesJsonPath() {
    return getPath([this.cachePath, "routes.json"]);
  }
  get redirectRoutesJsonPath() {
    return getPath([this.cachePath, "redirect-routes.json"]);
  }
  get payloadPath() {
    return getPath([this.publicFolder, "payload"], true);
  }
  get imageFolderPath() {
    getPath([this.publicFolder, "uploads"], true);
    return this.publicFolder;
  }
  get storePath() {
    return getPath([commonContainer.buildOptions.rootDir, "store", "index.ts"], false);
  }
  get routerPath() {
    return getPath([commonContainer.buildOptions.rootDir, "router", "index.ts"], false);
  }
  get layoutsPath() {
    return getPath([commonContainer.buildOptions.rootDir, "layouts"], false);
  }
  get componentsPath() {
    return getPath([commonContainer.buildOptions.rootDir, "components"], false);
  }
  get pluginsPath() {
    return getPath([commonContainer.buildOptions.rootDir, "plugins", "index.ts"], false);
  }
  get pagesPath() {
    return getPath([commonContainer.buildOptions.rootDir, "pages"], false);
  }
  get tzJsPath() {
    return getPath([this.distPath, "tz.js"], false);
  }
  getExistsFilesOrFolders() {
    return {
      components: this.pathExists(this.componentsPath),
      layouts: this.pathExists(this.layoutsPath),
      router: this.pathExists(this.routerPath),
      store: this.pathExists(this.storePath),
      addLib: this.pathExists(this.addLibPath),
      useVue: this.pathExists(this.pluginsPath),
      pages: this.pathExists(this.pagesPath)
    };
  }
  pathExists(filePath) {
    return existsSync(filePath);
  }
  removeDirSync(path2) {
    removePath(path2);
  }
  deleteFile(path2) {
    deleteFile(path2);
  }
  getPath(path2) {
    return getPath(path2, true);
  }
  getFilePath(directories, fileName) {
    return path.join(getPath(directories), fileName);
  }
}

function readFileSync(path, isString = false) {
  if (existsSync(path)) {
    var content = fs.readFileSync(path, "utf-8");
    content = isString ? content : JSON.parse(content);
    return content;
  }
}

function resolvePath(fPath) {
  return path.resolve(process.cwd(), fPath);
}

function isArray(value) {
  return value && Array.isArray(value);
}

function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}

function deepMerge(object, source) {
  Object.keys(source).forEach((prop) => {
    if (object[prop] === void 0)
      object[prop] = source[prop];
    else if (isObject(source[prop]))
      deepMerge(object[prop], source[prop]);
    else if (isArray(source[prop]))
      object[prop] = source[prop];
    else
      object[prop] = source[prop];
  });
  return object;
}

const commonContainer = new class {
  constructor() {
    this.tezConfig = {};
    this.expressConfig = {};
    this.ignoreColumns = ["createdAt", "publishedAt", "id", "published_at", "created_at", "ParentPage", "__component", "provider"];
    this.defaultTezConfig = {
      payload: {
        page: { maxPreLoadComponent: 3 }
      },
      build: {
        inLinCss: true,
        inLineJs: true
      }
    };
    this.strapiModuleConfig = {
      version: 4,
      payloadRootPath: "public",
      isDev: true,
      siteUrl: "http://localhost:3000",
      apiUri: DEFAULT_STRAPI_URL,
      pageCollectionConfig: {
        name: "pages",
        fieldName: {
          title: "title",
          uri: "Slug"
        }
      },
      media: {
        uris: [DEFAULT_STRAPI_URL],
        cdnUri: DEFAULT_STRAPI_URL
      },
      robots: {
        environmentName: "Dev"
      },
      componentDataFieldSelectors: {},
      limit: 1e4,
      serializeJson: { isCamelCase: true },
      optimization: {
        sourcePagination: true
      },
      pagination: {
        pageSize: 10
      }
    };
  }
  setupConfig(tezConfig) {
    if (tezConfig) {
      this.tezConfig = tezConfig;
      this.setDefaultStrapi();
      this.setExpress();
      this.tezConfig = deepMerge(this.defaultTezConfig, this.tezConfig);
    }
  }
  setDefaultStrapi() {
    if (typeof this.tezConfig.strapi === "boolean")
      this.tezConfig.strapi = this.strapiModuleConfig;
    if (this.tezConfig.strapi) {
      let strapi = this.tezConfig.strapi;
      strapi = deepMerge(this.strapiModuleConfig, this.tezConfig.strapi);
      this.tezConfig.strapi = strapi;
      strapi.ignoreColumns = strapi.ignoreColumns ? strapi.ignoreColumns.concat(...this.ignoreColumns) : this.ignoreColumns;
    }
  }
  getStrapiConfig() {
    return this.tezConfig.strapi ? this.tezConfig.strapi : {};
  }
  getAppRoutes() {
    var commonPath = new CommonPathResolver();
    let routes = readFileSync(commonPath.routesJsonPath);
    return routes || [];
  }
  setExpress() {
    if (this.tezConfig && this.tezConfig.express && this.tezConfig.express.path) {
      let configPath = resolvePath(this.tezConfig.express.path);
      if (existsSync(configPath))
        this.expressConfig = require(configPath);
    }
  }
}();

async function writeFileSync(path, content, isString = false) {
  content = !isString ? JSON.stringify(content) : content;
  await fs.writeFileSync(path, content);
}

function subText(text, from, to) {
  return text.substr(from, to);
}

function getUrlLastPath(url) {
  let lastUrlNode = url;
  if (url) {
    let splitUrl = url.split(/\/|\\/);
    lastUrlNode = path.sep + splitUrl[splitUrl.length - 1];
  }
  return lastUrlNode;
}

class PayloadReader {
  constructor(route) {
    this.route = route;
    this.commonPath = new CommonPathResolver();
    this.lastUrlPath = route && route.fPath ? getUrlLastPath(route.fPath) : "";
    this.isComponentExists = this.commonPath.pathExists(this.componentPath);
    this.isTagsExists = this.commonPath.pathExists(this.tagsPath);
  }
  get componentPath() {
    return getPath([this.commonPath.payloadPath, this.route.fPath, `${this.lastUrlPath}.json`]);
  }
  get masterPagePath() {
    return getPath([this.commonPath.payloadPath, "master-pages", `${this.components.masterPage.replace(/ /g, "-").toLowerCase()}.json`]);
  }
  get tagsPath() {
    return getPath([this.commonPath.payloadPath, this.route.fPath, "tags.json"]);
  }
  get components() {
    if (!this._components && this.isComponentExists)
      this._components = readFileSync(this.componentPath);
    return this._components || {};
  }
  get tags() {
    if (!this._tags && this.isTagsExists)
      this._tags = readFileSync(this.tagsPath);
    return this._tags || {};
  }
  get masterPage() {
    if (!this._masterPage && this.components.masterPage)
      this._masterPage = readFileSync(this.masterPagePath);
    return this._masterPage || {};
  }
  getData(componentName) {
    let componentDataPath = getPath([this.commonPath.payloadPath, this.route.fPath, `${componentName}.json`]);
    let data = {};
    if (this.commonPath.pathExists(componentDataPath))
      data = readFileSync(componentDataPath);
    return data;
  }
}

export { CommonPathResolver, PayloadReader, commonContainer, createPath, deepMerge, getPath, isArray, isObject, readFileSync, resolvePath, subText, writeFileSync };

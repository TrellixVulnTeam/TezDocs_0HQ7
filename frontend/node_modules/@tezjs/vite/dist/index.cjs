'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const common = require('@tezjs/common');
const fs = require('fs');
const path = require('path');
const htmlMinifier = require('html-minifier');
const crypto = require('crypto');
const dotenv = require('dotenv');
const dotenvExpand = require('dotenv-expand');
const c12 = require('c12');
const payload = require('@tezjs/payload');
const esbuild = require('esbuild');
const vite = require('vite');
const vue = require('@vitejs/plugin-vue');
const express = require('express');
const getPortPlease = require('get-port-please');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    const n = Object.create(null);
    if (e) {
        for (const k in e) {
            n[k] = e[k];
        }
    }
    n["default"] = e;
    return n;
}

const fs__namespace = /*#__PURE__*/_interopNamespace(fs);
const path__namespace = /*#__PURE__*/_interopNamespace(path);
const crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);
const dotenv__default = /*#__PURE__*/_interopDefaultLegacy(dotenv);
const dotenvExpand__default = /*#__PURE__*/_interopDefaultLegacy(dotenvExpand);
const vue__default = /*#__PURE__*/_interopDefaultLegacy(vue);
const express__namespace = /*#__PURE__*/_interopNamespace(express);
const express__default = /*#__PURE__*/_interopDefaultLegacy(express);

const NAME = "name";
process.cwd();
const BLANK = "";
const ENVIRONMENTS = "environments";
const DIST = "dist\\";
const BACKSLASH = "\\";
const RIGHTSLASH = "/";
const DOT = ".";
const SERVICE_WORKER_JS = "sw.js";
const JS = "js";
const CSS = "css";
const HTML = "html";
const JSON$1 = "json";
const CLIENT_ENV_SUBSTRING = "client_";
const SERVICE_WORKER_JS_PATH = () => common.getPath([common.commonContainer.buildOptions.rootDir, "node_modules", "@tezjs", "vite", "templates", "sw._js"], false);
const TZ_JS_PATH = () => common.getPath([common.commonContainer.buildOptions.rootDir, "node_modules", "@tezjs", "vite", "templates", "tz-web-worker.js"], false);
const REGISTER_SERVICE_WORKER_JS_PATH = () => common.getPath([common.commonContainer.buildOptions.rootDir, "node_modules", "@tezjs", "vite", "templates", "registerSW._js"], false);
const POST_SCRIPT_COMMENT = "/*POST_SCRIPT*/";
const EXPORT_DEFAULT = "export default";
const WINDOW_TEZ_DATA = "window.TEZ_DATA = ";

function getPaths(directoryPath, filterExtension) {
  var regex = new RegExp(`.*[.](${filterExtension})$`);
  var filePaths = [];
  if (!fs__namespace.existsSync(directoryPath)) {
    console.log("no dir ", directoryPath);
    return [];
  }
  var files = fs__namespace.readdirSync(directoryPath);
  for (var i = 0; i < files.length; i++) {
    var filename = path__namespace.join(directoryPath, files[i]);
    var stat = fs__namespace.lstatSync(filename);
    if (stat.isDirectory()) {
      getPaths(filename, filterExtension).forEach((t) => filePaths.push(t));
    } else if (regex.test(filename) || filterExtension === "") {
      filePaths.push(filename);
    }
  }
  return filePaths.sort();
}

function minifyJs(content) {
  return htmlMinifier.minify(content, {
    minifyJS: true,
    collapseWhitespace: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true
  });
}

function getChecksum(filePath) {
  return new Promise(function(resolve, reject) {
    const hash = crypto__namespace.createHash("md5");
    const input = fs__namespace.createReadStream(filePath);
    input.on("error", reject);
    input.on("data", function(chunk) {
      hash.update(chunk);
    });
    input.on("close", function() {
      resolve(hash.digest("hex"));
    });
  });
}

async function getFilesChecksum(files) {
  const jObject = { scripts: {}, styles: {}, json: {}, html: {} };
  for (const filePath of files) {
    var file = filePath;
    file = file.split(DIST).pop().replace(BACKSLASH, RIGHTSLASH);
    var extension = file.split(DOT).pop();
    switch (extension) {
      case JS:
        if (file !== SERVICE_WORKER_JS)
          jObject.scripts[`/${file}`] = await getChecksum(filePath);
        break;
      case CSS:
        jObject.styles[`/${file}`] = await getChecksum(filePath);
        break;
      case HTML:
        file = file.replace("\\index.html", BLANK).replace("/index.html", BLANK).replace("index.html", BLANK).replace("index", BLANK);
        jObject.html[`/${file}`] = await getChecksum(filePath);
        break;
      case JSON$1:
        jObject.json[`/${file}`] = await getChecksum(filePath);
        break;
    }
  }
  return jObject;
}

async function generateSW() {
  if (fs__namespace.existsSync("./dist")) {
    var files = getPaths("./dist", "");
    var jObject = await getFilesChecksum(files);
    var code = `const assets = {
            scripts:${JSON.stringify(jObject.scripts)},
            styles:${JSON.stringify(jObject.styles)},
            html:${JSON.stringify(jObject.html)},
            json:${JSON.stringify(jObject.json).replace(/\\/g, "/").replace(new RegExp("//", "g"), "/")}
            };`;
    var swScript = common.readFileSync(SERVICE_WORKER_JS_PATH(), true);
    var registerSW = common.readFileSync(REGISTER_SERVICE_WORKER_JS_PATH(), true);
    common.writeFileSync("./dist/registerSW.js", minifyJs(registerSW), true);
    common.writeFileSync("./dist/sw.js", minifyJs(`${code}${swScript}`), true);
    if (common.commonContainer.tezConfig.pwa)
      common.writeFileSync("./dist/manifest.json", common.commonContainer.tezConfig.pwa);
  }
}

function tsDefinition(value) {
  const definition = /^(true|false)+$/i.test(value) ? "boolean" : /^[0-9]+$/.test(value) ? "number" : "string";
  const transformValue = definition === "boolean" ? Boolean(value) : definition === "number" ? Number(value) : value;
  return { definition, transformValue };
}

function getParsedEnv(parsed) {
  let serverEnv = void 0;
  let clientEnv = {};
  let clientTypedDefinition = {};
  let serverTypedDefinition = {};
  if (parsed) {
    serverEnv = {};
    const keys = Object.keys(parsed);
    if (keys.length > 0) {
      keys.forEach((key) => {
        let keyName = key;
        const { definition, transformValue } = tsDefinition(parsed[key]);
        if (key.length > CLIENT_ENV_SUBSTRING.length && common.subText(key, 0, CLIENT_ENV_SUBSTRING.length).toLowerCase() === CLIENT_ENV_SUBSTRING.toLowerCase()) {
          keyName = common.subText(key, CLIENT_ENV_SUBSTRING.length, key.length);
          serverTypedDefinition[keyName] = definition;
          clientTypedDefinition[keyName] = definition;
          clientEnv[keyName] = transformValue;
          serverEnv[keyName] = transformValue;
          parsed[keyName] = parsed[key];
        } else {
          serverTypedDefinition[keyName] = definition;
          serverEnv[keyName] = transformValue;
        }
      });
    }
    if (common.commonContainer.buildOptions.commandName === "build")
      parsed.VITE_USER_NODE_ENV = "production";
  }
  return { parsed, client: { env: clientEnv, typedDefinition: clientTypedDefinition }, server: { env: serverEnv || parsed, typedDefinition: serverTypedDefinition } };
}

function writeTsCode(keyDefinition, path) {
  let content = Object.keys(keyDefinition.env).length > 0 ? `export const env : ${JSON.stringify(keyDefinition.typedDefinition).replace(/\"/g, "")}  = ${JSON.stringify(keyDefinition.env)}` : `export const env:any={}`;
  common.writeFileSync(path, content, true);
}

function writeEnv(parsedEnv) {
  let pathResolver = new common.CommonPathResolver();
  if (parsedEnv?.client)
    writeTsCode(parsedEnv.client, pathResolver.clientEnvPath);
  if (parsedEnv?.server)
    writeTsCode(parsedEnv.server, pathResolver.serverEnvPath);
}

async function setupConfig(config) {
  let tezConfig = config;
  let clientConfig = void 0;
  if (typeof config === "function") {
    clientConfig = config(common.commonContainer.buildOptions);
    if (clientConfig instanceof Promise)
      tezConfig = await clientConfig;
    else
      tezConfig = clientConfig;
  } else
    tezConfig = config;
  if (tezConfig)
    common.commonContainer.setupConfig(tezConfig);
}

async function readConfig() {
  let filePath = common.getPath([common.commonContainer.buildOptions.rootDir, ENVIRONMENTS, common.commonContainer.buildOptions.mode ? `.env.${common.commonContainer.buildOptions.mode}` : `.env`], false);
  const port = 3e3;
  let parsedEnv = {};
  if (fs.existsSync(filePath)) {
    const { parsed, error } = dotenv__default.config({
      debug: !!process.env.DEBUG || void 0,
      path: filePath
    });
    parsedEnv = getParsedEnv(parsed);
    dotenvExpand__default.expand({ parsed: parsedEnv.parsed });
    if (!common.commonContainer.buildOptions.port)
      common.commonContainer.buildOptions.port = parsedEnv.server.env.PORT || parsedEnv.server.env.TEZ_PORT || port;
  }
  const { config: tezConfig } = await c12.loadConfig({
    name: "tez",
    configFile: "tez.config",
    dotenv: true,
    cwd: common.commonContainer.buildOptions.rootDir
  });
  setupConfig(tezConfig);
  writeEnv(parsedEnv);
}

function isPageComponent(name) {
  return name.indexOf("pages/") !== -1;
}

const depsContainer = new class {
  setDeps(deps) {
    this.deps = deps;
  }
  getDeps() {
    return this.deps;
  }
}();

const routeComponentWriter = new class {
  constructor() {
    this.routeComponents = {};
  }
  addComponent(path, component, isPre, isLayout = false) {
    this.depsConfig = depsContainer.getDeps();
    let componentSuffix = isLayout ? "layout" : "component";
    componentSuffix = isPageComponent(component) ? "page" : componentSuffix;
    let key = isPre ? "pre" : "post";
    if (!this.routeComponents[path])
      this.routeComponents[path] = { pre: new Array(), post: new Array() };
    let componentFileName = `${payload.getFriendlyComponentName(component)}.${componentSuffix}`;
    this.routeComponents[path][key].push(componentFileName);
    if (!this.routeComponents[path].deps)
      this.routeComponents[path].deps = { pre: new Array(), post: new Array() };
    this.addDeps(path, componentFileName, key);
  }
  addDeps(routePath, name, keyName) {
    const filePath = `assets/${name.toLowerCase()}.${common.commonContainer.buildOptions.buildVersion}.js`;
    if (this.depsConfig && this.depsConfig.deps && this.depsConfig.deps[filePath]) {
      this.addJsRefs(routePath, filePath, keyName);
    }
  }
  addJsRefs(routePath, filePath, keyName) {
    if (this.depsConfig.deps[filePath]) {
      const dependencyConfig = this.depsConfig.deps[filePath];
      dependencyConfig.js.forEach((path) => {
        let isNotExist = this.addPath(routePath, path, keyName);
        if (isNotExist)
          this.addJsRefs(routePath, path, keyName);
      });
      dependencyConfig.css.forEach((path) => {
        this.addPath(routePath, path, keyName);
      });
      this.addPath(routePath, filePath, keyName);
    }
  }
  addPath(routePath, filePath, keyName) {
    let collection = this.routeComponents[routePath].deps[keyName];
    let isNotExist = collection.filter((t) => t === filePath).length === 0 && this.depsConfig.excludes.filter((t) => t === filePath).length === 0;
    if (isNotExist)
      collection.push(filePath);
    return isNotExist;
  }
  getRouteComponent(path) {
    if (this.routeComponents[path])
      return this.routeComponents[path];
    return {};
  }
  getPreDeps(path) {
    if (this.routeComponents[path])
      return this.routeComponents[path].deps.pre;
    return [];
  }
  getPostDeps(path) {
    if (this.routeComponents[path])
      return this.routeComponents[path].deps.post;
    return [];
  }
}();

function getInputOptionName(name) {
  return `${name.toLowerCase()}.${common.commonContainer.buildOptions.buildVersion}`;
}

function snakeToCamel(value) {
  return payload.getFriendlyComponentName(value.split("-").map((t, i) => {
    var textCode = "";
    for (var i = 0; i < t.length; i++) {
      let character = t.charAt(i);
      let isNotNumber = textCode === "" ? isNaN(character) : true;
      if (isNotNumber) {
        textCode += character;
      }
    }
    return String(textCode);
  }).join(""));
}

function getImportStatement(name, path) {
  let buildComponentSuffix = {
    components: "component",
    pages: "page",
    layouts: "layout"
  };
  let componentPath = `"/@/${path}/${name.replace("pages/", "")}.vue"`;
  if (common.commonContainer.buildOptions.commandName === "build")
    componentPath = `"${getInputOptionName(`/assets/${payload.getFriendlyComponentName(name).toLowerCase()}.${buildComponentSuffix[path]}`)}.js"`;
  return `import ${snakeToCamel(name)} from ${componentPath};`;
}

function getPreComponents(pageSlots, masterPageSlots, isPre) {
  let preComponents = new Array();
  let maxPreLoadComponent = isPre ? common.commonContainer.tezConfig.payload.page.maxPreLoadComponent : pageSlots && pageSlots.default ? pageSlots.default.length : 0;
  let propName = isPre ? "header" : "footer";
  if (masterPageSlots && masterPageSlots[propName])
    masterPageSlots[propName].forEach((item) => {
      if (preComponents.filter((x) => x !== pageSlots.default[i].name).length === 0) {
        preComponents.push(item.name);
      }
    });
  if (pageSlots && pageSlots.default) {
    for (var i = 0; i < maxPreLoadComponent; i++) {
      if (pageSlots.default.length > i && preComponents.filter((x) => x === pageSlots.default[i].name).length === 0) {
        if (pageSlots.default[i].mobileComponentName)
          preComponents.push(pageSlots.default[i].mobileComponentName);
        preComponents.push(pageSlots.default[i].name);
      }
    }
  }
  return preComponents;
}
function depsCodeTemplate(page, route, isPre = true, isPage = false) {
  let components = ``;
  let masterPage = "";
  let componentRefs = `{`;
  let masterPageRefs = `{`;
  let componentPropName = "";
  for (let name of getPreComponents(page.slots, page.masterPageSlots, isPre)) {
    const propName = snakeToCamel(name);
    componentPropName = propName;
    componentRefs += `"${name}":${propName},`;
    components += getImportStatement(name, name.indexOf("pages/") === -1 ? "components" : "pages");
    routeComponentWriter.addComponent(route.path, name, isPre, false);
  }
  componentRefs += "}";
  if (page.layoutName) {
    masterPage += getImportStatement(page.layoutName, "layouts");
    masterPageRefs += `"${page.layoutName}":${snakeToCamel(page.layoutName)},`;
    routeComponentWriter.addComponent(route.path, page.layoutName, isPre, true);
  }
  masterPageRefs += "}";
  let postScript = "";
  if (page.postScript) {
    if (common.commonContainer.buildOptions.commandName === "dev")
      postScript = `postScript: ()=>import("${page.postScript}")`;
    else
      postScript = `postScript: ${POST_SCRIPT_COMMENT}`;
  }
  if (isPage) {
    page.layoutName = `${componentPropName}.layout ? {[${componentPropName}.layout]:import("/@/layouts/${componentPropName}.layout")}:{}`;
  }
  delete page.postScript;
  return `
        ${components}
        ${masterPage}
        export default function(registerTezPage,preload){
            const payload = ${JSON.stringify(page)}; 
            registerTezPage({
                components:${componentRefs},
                masterPage:${isPage ? `${componentPropName}.layoutName ? {[${componentPropName}.layoutName]:()=>import(${`/* @vite-ignore */"/@/layouts/"+${componentPropName}.layoutName+".vue"`}).then(t=>t.default)}:{}` : masterPageRefs},
                payload:${isPage ? `{...payload,...{isPage:${isPage},layoutName:${componentPropName}.layoutName,tags:${componentPropName}.head}}` : `payload`},
                ${postScript}
            })
        }    `;
}

function getComponentName(name) {
  if (name.indexOf("-") !== -1) {
    let splitText = name.split("-");
    if (!isNaN(splitText[0])) {
      let dashIndex = name.indexOf("-");
      name = name.substr(dashIndex + 1, name.length);
    }
  }
  return name;
}

function getUrl(url) {
  return url === "/" ? "/index" : url === "/index" ? "/" : url;
}

function getPreloadCodeTemplate(preloads, commonPath) {
  let code = `return import('./pre');`;
  if (common.commonContainer.buildOptions.commandName === "build") {
    code = `    return preload(()=> import('./${commonPath.preScriptName}'),${JSON.stringify(preloads)});`;
  }
  return `export default function(preload){
        ${code}
    }`;
}
function postScriptPreloadCodeTemplate(preloads, commonPath) {
  return `()=> preload(()=> import('./${commonPath.postScriptName}'),${JSON.stringify(preloads)})`;
}

class JsCodeGen extends common.PayloadReader {
  constructor(route) {
    super(route);
    this.route = route;
    this.postSlots = { slots: {}, masterPageSlots: {} };
  }
  isPostCode() {
    return Object.keys(this.postSlots.masterPageSlots).length > 0 || Object.keys(this.postSlots.slots).length > 0;
  }
  gen() {
    let writePath = common.commonContainer.buildOptions.commandName === "build" ? this.commonPath.distPath : this.commonPath.depsPath;
    let preCode = this.preCode();
    let postCode = this.postCode();
    let preloadCode = getPreloadCodeTemplate(routeComponentWriter.getPreDeps(this.route.path), this.commonPath);
    let postScriptPreload = postScriptPreloadCodeTemplate(routeComponentWriter.getPostDeps(this.route.path), this.commonPath);
    const preFile = common.getPath([this.commonPath.getPath([writePath, this.route.fPath]), this.commonPath.preScriptName]);
    const preloadFile = common.getPath([this.commonPath.getPath([writePath, this.route.fPath]), this.commonPath.preloadScriptName]);
    preCode = preCode.replace(POST_SCRIPT_COMMENT, postScriptPreload);
    common.writeFileSync(preloadFile, preloadCode, true);
    if (common.commonContainer.buildOptions.commandName === "build") {
      const preInlineFile = common.getPath([this.commonPath.getPath([writePath, this.route.fPath]), "pre.inline.js"]);
      const preInlineCode = preCode.replace(EXPORT_DEFAULT, WINDOW_TEZ_DATA);
      common.writeFileSync(preInlineFile, preInlineCode, true);
    }
    common.writeFileSync(preFile, preCode, true);
    if (this.isPostCode) {
      const postFile = common.getPath([this.commonPath.getPath([writePath, this.route.fPath]), this.commonPath.postScriptName]);
      common.writeFileSync(postFile, postCode, true);
    }
  }
  preCode() {
    return depsCodeTemplate({
      url: this.route.path,
      slots: this.getSlots(this.components, true),
      masterPageSlots: this.getSlots(this.masterPage, false),
      tags: this.tags,
      layoutName: this.masterPage.layoutName,
      postScript: this.isPostCode ? common.commonContainer.buildOptions.commandName === "dev" ? `/tez/deps${getUrl(this.route.path)}/post.js` : `./${this.commonPath.postScriptName}` : ""
    }, this.route, true, this.route.isPage);
  }
  postCode() {
    return depsCodeTemplate({
      url: this.route.path,
      slots: this.postSlots.slots,
      masterPageSlots: this.postSlots.masterPageSlots
    }, this.route, false);
  }
  getSlots(page, isPageSlot = true) {
    let pageSlot = {};
    if (page.slots) {
      const slots = Object.keys(page.slots);
      for (const slotName of slots) {
        let components = page.slots[slotName];
        let itemCount = 0;
        for (const componentItem of components) {
          let itemName = componentItem[componentItem.length > 1 ? 1 : 0];
          let componentName = getComponentName(itemName);
          let data = componentItem.length > 1 ? componentItem[0] : void 0;
          if (!pageSlot)
            pageSlot = {};
          if (!pageSlot[slotName])
            pageSlot[slotName] = [];
          let jObject = {
            name: componentName,
            data,
            id: itemName
          };
          if (data && data.mobileComponentName)
            jObject["mobileComponentName"] = data.mobileComponentName;
          pageSlot[slotName].push(jObject);
          if (slotName === "default" && isPageSlot && itemCount >= common.commonContainer.tezConfig.payload.page.maxPreLoadComponent) {
            if (!this.postSlots.slots[slotName])
              this.postSlots.slots[slotName] = [];
            jObject = {
              name: componentName,
              data: this.getData(itemName),
              id: itemName
            };
            if (jObject.data && jObject.data.mobileComponentName)
              jObject["mobileComponentName"] = jObject.data.mobileComponentName;
            this.postSlots.slots[slotName].push(jObject);
          } else if (slotName === "footer" && !isPageSlot) {
            if (!this.postSlots.masterPageSlots[slotName])
              this.postSlots.masterPageSlots[slotName] = [];
            this.postSlots.masterPageSlots[slotName].push({
              name: componentName,
              data,
              id: itemName
            });
          }
          itemCount++;
        }
      }
    }
    return pageSlot;
  }
}

const indexTemplate = (seo) => {
  return `<!DOCTYPE html>
<html lang="${seo.htmlMeta.lang || "en"}">
<head>
        ${seo.headChildElements}
</head>
      <body>
        <div id="tez_app"></div>
        ${common.commonContainer.buildOptions.commandName === "dev" ? '<script type="module" src="/tez.ts"><\/script>' : ""}
        ${seo.bodyChildElements}
      </body>
    </html>`;
};

const PROPERTY = "property";

const tezTemplate = (importState) => {
  return `
    import { createTezApp } from '@tezjs/vue';
    ${importState.imports}
    createTezApp({
        ${importState.props}
    });
    `;
};

const appContainer = new class {
  constructor() {
    this.versionId = 1;
    this.pathResolver = new common.CommonPathResolver();
    this.build = { route: { path: "", fPath: "" } };
  }
  async addOrUpdateTezTS(route) {
    this.build.route = route;
    let refrenceState = { imports: "", props: "", runtimeImports: "" };
    let existsFilesorFolders = this.pathResolver.getExistsFilesOrFolders();
    if (!this.importState) {
      ["useVue"].forEach((key) => {
        if (existsFilesorFolders[key])
          refrenceState.imports += `import ${key} from '/@/${key === "useVue" ? "plugins" : key}';`;
      });
      if (common.commonContainer.tezConfig.client && common.commonContainer.tezConfig.client.imports)
        common.commonContainer.tezConfig.client.imports.forEach((item) => refrenceState.imports += `import '${item}';`);
      if (existsFilesorFolders.addLib) {
        refrenceState.imports += `
import addLib from '/@/add-lib'; addLib();`;
        delete existsFilesorFolders.addLib;
      }
    } else
      refrenceState = this.importState;
    refrenceState.props = this.getProps(existsFilesorFolders);
    let tsCode = tezTemplate(refrenceState);
    if (this.tsCodeCache !== tsCode)
      common.writeFileSync(this.pathResolver.tezTsPath, tsCode, true);
    this.tsCodeCache = tsCode;
    this.importState = refrenceState;
    return refrenceState;
  }
  getProps(existsFilesorFolders) {
    let props = "";
    if (common.commonContainer.tezConfig.client && common.commonContainer.tezConfig.client.loaderImage)
      props += `loaderImagePath:"${common.commonContainer.tezConfig.client.loaderImage}",`;
    props += `isDevMode:${common.commonContainer.buildOptions.commandName === "dev"},`;
    if (existsFilesorFolders.useVue)
      props += `useVue:useVue,`;
    props += `buildVersion:${common.commonContainer.buildOptions.buildVersion},`;
    props += `maxPreComponentCount:${this.getPreComponentCount()},`;
    return props;
  }
  getPreComponentCount() {
    return common.commonContainer.tezConfig.payload?.page?.maxPreLoadComponent || 3;
  }
}();

class Seo extends JsCodeGen {
  constructor(route) {
    super(route);
    this.htmlMeta = vite.mergeConfig(common.commonContainer.tezConfig.htmlMeta, { head: this.tags });
    this.preHeadElements = new Array();
    this.postHeadElements = new Array();
    this.bodyElements = new Array();
  }
  get headChildElements() {
    return `${this.preElementString}
${this.postElementString}`;
  }
  get bodyChildElements() {
    return this.bodyChildElementString;
  }
  buildElements() {
    this.addTitle();
    this.addInlineStyle();
    this.addPreConnects();
    this.addPreFetchDns();
    this.addPreloads();
    this.addCanonical();
    this.setMetaTags();
    this.addPageSchema();
    this.addFavicon();
    this.addViewport();
    this.addPreFetch();
    this.addBody();
  }
  addViewport() {
    this.addHeadChildElement(`<meta name="viewport" content="width=device-width" />`, true);
  }
  addTitle() {
    if (this.htmlMeta.head.title)
      this.addHeadChildElement(`<title data-head="tezjs">${this.htmlMeta.head.title}</title>`, true);
  }
  addCanonical() {
    if (this.htmlMeta.head.canonical)
      this.addHeadChildElement(`<link data-head="tezjs" rel="canonical" href="${this.htmlMeta.head.canonical}"/>`, false);
  }
  setMetaTags() {
    if (this.htmlMeta.head.metaTag) {
      this.addMetaTags(NAME);
      this.addMetaTags(PROPERTY);
    }
  }
  addMetaTags(type) {
    if (this.htmlMeta.head.metaTag[type]) {
      Object.keys(this.htmlMeta.head.metaTag[type]).forEach((key) => {
        this.addMeta(type, key, this.htmlMeta.head.metaTag[type][key]);
      });
    }
  }
  addMeta(type, key, content) {
    this.addHeadChildElement(`<meta data-head="tezjs" ${type}="${key}" content="${content}">`, false);
  }
  addFavicon() {
    if (this.htmlMeta.head.favicon)
      this.addHeadChildElement(`<link rel="icon" href="${this.htmlMeta.head.favicon}"/>`, false);
    else
      this.addHeadChildElement(`<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAADsZJREFUeNrsXVtsHNUZ/ne9vq+ddW3HCdgkBEgCVRKbINFAVRLRRi1S1UQFVW0fIBJCatUWIvGC+gCpVLUPlSBtJV4qJekDqGqhDlAKES0OITgUHEICISQkODjEd3vjXd9vPd+ZOcPZuexcvDO7tueTjmbv3v2/+S/ff84ZE4UIESJEiBAhQoQIESJEsIgso9+6Vh1Ago1mk9eskV5jhk42Lps8foqNpHo7qd5f1oQIYzerxhaGtTJ8UOhUB0j6UCJLPL7oCRFGx9gi3V+sOKUOeF0bRmQRGP8e9bjdy4eUVVZRebxKvR3XbovnMMxQVVNLsZIS0+cmRlM0nk6bPpfsu6rdHk+n2GuV1w33XnUUsSIFRsB2lYDtNrE8w3AwatXXmAGLSyheU8cNice9oqKsjMrZsML4xASNseEFqeFBmpma4sSlhgap/0qn7C0tsTyTsEslYJcdAYqR66imYTUzukqCA6ML49bVJPj96nicimPKz8YR93OFEeY10zMz/DaOI6oXjY0rBIrnAPyO7kvnZULa+O8MmICEavwfqMesZz4MX9NwHf/yVqHFDrIhQE6MkVCXSOSUCAH9Z66qqzO8pmdggN4785FZGDscFCGOSIDBYfj6prVUs/I6y/jtBSBkMJmkQW4R0rwDBlvX1GhJTuPqla7/1pXuPlsvEpC8IxAPgfEfzEYCzv76xjWcBK8e4BQ3rWmieEU5GxX8Nj+D62upoa6WE1Jbs4IdK3P6N0fSo/TuyTN09sLn2mPXUumMXCKT4QchyAOPsvGQ6hkG1Deu5QTgmEsvUAzdqBq5jt8Wj+GYD4DgyalpQwgFBjK943CuCdmlErE9CBK23Lqen+Wr2NmNYz6Nbof+wWHTkNXfZQxXCyUkoXrCo2YVEpLy6nXr2diwIBKE8W+G4W9o1MINMPWVy2u3I9GoVkXlGwhZGALIYwBCFUKWWasl5pGIx1QiEvrSFF7QtHGTJx2As1wQgCMGEvLM9DTNzs4x95+igcFBmp6esf2soqIiKmHfp7SkmMrLy/NCiD7BXxPekRmuWjNsmAsiYHyQ4CUkKYbfwI+bNt7Cz/QZZnAYv7un17MxZmdnaXx8nI+RVIpWrFhBZaWlgRLyZXfm9x8cTlqWu24IsSRCeAPKVTdecPcdW+iurc2chFJG4OTEJCegt7fPF8PMzc3TMDMGPCWxojpvHiJCllm565QQEPGkngjkhnWbtzouVWUS7mZjYnKSJhgJY6NjlBpJBWYgeEtZWWkgnqLPH0LFD/d268vdpBNCUC0dkJM1QtENzBuaNmxyFJasSOjt6+NnbN4SLTsByur9J+Ti5SsZ9wfMveOwoUVkoiOelsWcEyLm5+fYUIy8jlVCD9z3HUZCC5WWltAo84J8k6DPLcHkjz7T/KErd1uzEWIIT2ahCYYXBMhEfPeebzIidtKNTdez0DBBY2MsHKVSVIhA4VCSQ1GqB/Kh3kOQP9C2x1AhJqpMCXlTFnXwhDvv+6FGxNwcDD/Lj3rseWAX3f+9ndwb0ixO9vUPUKHDTzKskjnyh5UYlBGVYpmWXJB0zrYf1diMRCKaJ+jxwcfntLq/UMKSnT7xG5d03tGjnqRot0s4ZPbeiK68PaDPH+u33sVDlxJ/Z5jRjTE4XllBv338V9R820ZKXhvh1UyhIlelL6+iUqOmz73yxjEetgT+036Chgb76Xjr8+IhuMqNdoRkzSUgBgSBEBBjBoSvh+7fxQkBMYWImpqEoeztHRhkZ/EgpVneE7H/4uUufh9Ij43z+wL3bvsGn1txAjQTQQi842y7FqWeYWOvU0JEtXVAzivIJ5vv2clVOcLX7Oy0aRiDl8BbSopjNMxip59hLBqNUCxWTMXsb0UjUX5Wyv0tMzQ0rGSvjaiGHqNdj+x1/Xebb91ITatWOQtfV67Qxxc+o9NHj8glbwtZLBWyCqhJNcZFBCkz01P05YVPqJh5yYr6BmYMvHXeQAri5f8+PEObN66n61c10BR7n1kx4MX4pezMLi8rp6p4JVVXV7NjnCpYCBpm2mKKJc1EdRWv8LIl88qKr/paJcXFdORYO/cAN+CTW/V1jl57+tPzNMqKnbMn2uRw9YTV6+2U+lNqrfxPIRLPd7RztXnbtu08hEUixhD2WecX9Ohvfk9P/OxhuuuOFrp27RoXhe4JKOPNwRgznOjgnjp7jn9+NyMeR9wXZfcTP3+Yv8/KK6HS9bjphiYertxAtECchCso9GzNRLeEiHq5RRWMDwm1efKNl+lWRgpCGKqwmZnMiZg0E4S//sMf6ZcP/oTuZ/oEDT6IxGyAwXAWY4AAeNuJU6fpgmp4EGCFt98/yY8g0aqoMGuZoJ92vMPdQsMxddWJXR7B/LmJGDy0UEJECNvDxlGVmAT6+SBFVGGxWIlpXvnToee4QXH2wshyskcJKkiAsUAiyugPmPHtCNAD78V7Nty4xpQQ/C2zkleeX3FXZaVtCenq7uESQvKQTrJZZup2PuSg+oFI+M2KXmnjky3rt25TSTGWxq8dfZuf7Uj2dXW1PPGCABhIhJ1j753Uwo9X4P2bNtziSgzCQ7wSYraqxCZcHbLVSR6+C9Zt/I2NjeqgkYE+SvZ1K/MhLN4rQnLONNlvu30Lnb1wkZ5/6d/0Z+Y9zx3+F3+8J0cK/74d3+KJXe+pVVVxvgTIDMc7PqRhD2V602rrSqurp4f6h4bo89MdNDai5Zw9+u7uQj1EDmG7Vc2CEMYnXeS8ggINIUyf7H/0i8d9K4PhIQhd8AZ92MrWLrl5TWOGznCCcZuViybhyrR3ZdU68QoInB2CdZFXUIVFo1EewiIBr1YFKajMMspUrlOsvwcqLbfItpTUIlztd1Rd5sAGbbLQwVkBUqBMQUbQpKAg0HsDxGM2eE3sVqRc6VFW43WdO+O43M0lIaJ62KEmfQ4ke9EqACmKkPQfCIsoFqBHZA/JBq+J3SpsIVyhMSutLDlolztyTYhcGu8TD4j+DbymqCgWCCmiUpO9xMmyIK9eYlZ9wXN02uOwY0Hsg02eUonRSEEIE6RgBEGK2zkPJHa3MFPsl7qU5uQX5z6So0drPgkRLtqiT/ZwY3iJXUzPBSFuF8t5SexW6hy/V5oZPOTm/VE/7aLmlVOClHdffYEfIxGlAvML6AzIHjI3Px9IyIL2wMygLpkfLBRCDKSICkwhxb8KTLRcRDK3a8kvJLHrxa9Oe7Q60R5BEiKS/Q4RR4Moi2EYCEQRGiESnXjJQkhBIke4AhnSuqv9bj8nCEJkZX9QkILqS8wx+0HKZ5e/0AQi2vFjNp1mAFsZvMJEe3SSxUKGQiBE7uVkaBWZlFyWxUjs6KsJpFg5ahe6FpLYoT0QiiXtsd/L5wRNCOm1ikxKLrVKd9+AodLiU8pZQpfbxC526iJUIWRJ3pF0m8zzSYhBq/hBiugeZ1RbLHQNDQ1ZknKTSy0i5kNEI1Fa5uNYmRcKIeJL+0aKUOz6tgn2lmBK2QxYj+x2J5ZI5l2fZpS6+71+73wS4jsp8BKzWULM71stU3LjJbWJhJbMr17M8I7OxUqIr6SAECvFjlI4nR71nEfE5yJc4ft6VeaFSIhvpNj1tMwqL2wkdQJspRbJ/NLpDvFwm5dStxAJcUCK+6+aUrVHtvW8CF1yknfqIbhUBxqJmIyTvGPfQo1QSITYkFLsWjyKFko2QrBfRBaNTsUhSl50ez8/0yG3idqWGiFZSXGr6EXpW2rTih+T5t8bHIYsbMCBd0gbOPfn4scXIiE5I0UQUlSU/WfCS+RcYhe2+CI+lj8k7+j0KgQXCyEGUs53vKO1JRC+3CR2J3tCpqRLYMQrsu9rR4t9qL9X9o59ufrRhUyIIAUrW0xb904h97SsIO/nwL55295VZhPx4HIhBNhLUpdYJsXJdDA8JOogxMmbQe08BFWV1CbZl8sfuxgIIZK6xCDlE3XhBPSJHSmi9LWbY5cJscshku7IqXcsJkIEKbysFHP0gpRswtHNgm0npa+f3rHYCAF2kzRHL9Z9wUusKi9RadmtzZKRrfT10zsWIyFiOhjG4NOl8mI8M1IEIdjylg1yJSb2FgbtHYuREEHKbvXIDSQqHqtyGKTEbDxEJuTF1/5r+prz77f76h2LlRDRptjxlUZp1xZNmJFy4O+tfD9KZaX1XIcc0o4ce8fwPFS5tJpkn18/rIgWLzARgUt08331w31Xqfa6JiqrqDTsT8GCB0SzO1u20AwuiDZj3GuPzaDF6ibQ199qNzz/yQntQgqdsmANCTF6Ct8pPMfK1t7LF6nxltuoiC//ydwhDD2yemUdfX0DLpI2adgZXF1dxTvKTz7zrGFXLrxDapPspQX894OlGrJkPKUXjso6YmN3GPsdL13uoppEwrA6HjkE3mG2I1cio82v3LGUCMk4a1EOo+9lluSxeO53z/6FxicmOSkCZaXKYoW/vviyae7wo2e11AkR5XBG5WWW5CEUQQqUe5V6Revy8jJL75Auh9FGOZjvWC6EyKRolZfYWqdX8m+/d5L+8eoRiscrOSkIV2beoZsr3xfEj1hKhIgkr1VAp996nRtUUfJRQz6Bt4AUK++QVHlrEN6xFAkhNelqSR4XfcHRbE8KrjSBvHLohZdME7nkHXuD+vJL+Z+CfUDqv0PClSZwbRZoE/0lQHARmcFk5qUIQeDxw8+JVewH/dQdy8FDBDLaK4qSjxra9WYXLMAqRJWMZJDesdQJ6VRJUZO8MgWstOutfzbClJQ79pPHNbrLVak7IUVT8rgESMOam/n/qhLXY4HXyFUYqrO0MncPIn4MjkIPyb2Sb9OLRpHkZTGPMllqr+8N2juWCyGGfIKurcgncjnsx7KekBBr0bhbVt9ii7YgBCRJLZI9+fqiy4UQ0frQlhThusRKyFJiljT5FEiLJESmPkFffn7d5q3z9/70EX4Uj5HDf2gZIndolow/f/u3vz8fKykR958OzZMfPCaTog78965EaJr84U0dIY+FJskv1qpeMa/mlRAFFLq2h6YoLFJChAgRIkSIECFChAgRYtni/wIMAKRkv7CiCA9OAAAAAElFTkSuQmCC"/>`, false);
  }
  addPageSchema() {
    if (this.htmlMeta.head.linkingData) {
      const splitLinkingData = this.htmlMeta.head.linkingData.split("--");
      splitLinkingData.forEach((data) => {
        this.addHeadChildElement(`<script data-head="tezjs"  type="application/ld+json">${JSON.stringify(JSON.parse(this.replaceText(data.trim())))}<\/script>`, false);
      });
    }
  }
  replaceText(text) {
    if (text.charAt(0) === "{" && text.charAt(1) === "'") {
      const keys = [
        new RegExp(/"/, "g"),
        new RegExp("\\['", "g"),
        new RegExp("\\']", "g")
      ];
      const replacer = [
        '\\"',
        '["',
        '"]'
      ];
      keys.forEach((key, index) => {
        text = text.replace(key, replacer[index]);
      });
      text = text.replace(/('(?=(,\s*')))|('(?=:))|((?<=([:,]\s*))')|((?<={)')|('(?=}))/g, '"');
    }
    return text.replace(/\\n/g, "").replace(/\n/g, "").replace(/\t/g, "");
  }
  addPreloads() {
    if (this.htmlMeta.head?.preloads) {
      this.htmlMeta.head.preloads.forEach((item) => {
        if (item.type === "module")
          this.addModulePreload(item.path, true);
        else
          this.addPreload(item.path, item.path.indexOf(".js") !== -1 ? "script" : item.path.indexOf(".css") !== -1 ? "style" : "image", true);
      });
    }
  }
  addPreload(path, as, forAll = false) {
    this.addHeadChildElement(`<link data-head="tezjs-preload" rel="preload" as="${as}" ${as === "script" ? "crossorigin" : ""}  href="${forAll ? path : `/${path.replace(/\/\//g, "/")}`}">`, true);
  }
  addModulePreload(path, forAll = false) {
    path = path.charAt(0) === "/" ? path : `/${path}`;
    this.addHeadChildElement(`<link data-head="tezjs-preload"  rel="modulepreload" href="${forAll ? path : `${path}`}">`, true);
  }
  addScript(path, isAppendToBody = false) {
    const elementString = `<script crossorigin="" type="module" src="/${path}"><\/script>`;
    if (!isAppendToBody)
      this.addHeadChildElement(elementString, false);
    else
      this.addBodyChildElement(elementString);
  }
  addStyle(path, isAppendToBody = false) {
    path = path.charAt(0) === "/" ? path : `/${path}`;
    const elementString = `<link rel="stylesheet" href="${path}"></link>`;
    if (!isAppendToBody)
      this.addHeadChildElement(elementString, false);
    else
      this.addBodyChildElement(elementString);
  }
  addManifestJson() {
    this.addHeadChildElement(`<link data-head="tezjs" rel="manifest" href="/manifest.json" crossorigin="use-credentials">`, true);
  }
  addInlineScript(name, code) {
    this.addBodyChildElement(`<script type="module" data-head="tezjs" >${code}<\/script>`);
  }
  addBody() {
    this.addDevScript();
    if (this.htmlMeta.body) {
      let body = this.htmlMeta.body;
      if (body.inlineScript)
        body.inlineScript.forEach((item) => {
          this.addInlineScript(item.name, item.code);
        });
      if (body.script)
        body.script.forEach((script) => this.addScript(script.src, true));
      if (body.style)
        body.style.forEach((style) => this.addStyle(style.href, true));
    }
  }
  addInlineStyle() {
    if (this.htmlMeta.head?.inlineStyle)
      this.htmlMeta.head?.inlineStyle.forEach((item) => {
        this.addHeadChildElement(`<style data-href="${item.name}" data-head="tezjs" >${item.code}</style>`, true);
      });
  }
  get preElementString() {
    return this.getElementString(this.preHeadElements);
  }
  get postElementString() {
    return this.getElementString(this.postHeadElements);
  }
  get bodyChildElementString() {
    return this.getElementString(this.bodyElements);
  }
  getElementString(elements) {
    let element = "";
    elements.forEach((t) => element += t);
    return element;
  }
  addHeadChildElement(element, isPre) {
    if (isPre)
      this.preHeadElements.push(`${element}
`);
    else
      this.postHeadElements.push(`${element}
`);
  }
  addBodyChildElement(element) {
    this.bodyElements.push(`${element}
`);
  }
  addPreConnects() {
    if (this.htmlMeta.head?.preConnect)
      this.htmlMeta.head?.preConnect.forEach((domain) => this.addHeadChildElement(`<link rel="preconnect" href="${domain}"/>`, true));
  }
  addPreFetchDns() {
    if (this.htmlMeta.head?.preFetchDns)
      this.htmlMeta.head?.preFetchDns.forEach((domain) => this.addHeadChildElement(`<link rel="dns-prefetch" href="${domain}"/>`, true));
  }
  addPreFetch() {
    if (this.htmlMeta.head?.preFetch)
      this.htmlMeta.head?.preFetch.forEach((path) => this.addHeadChildElement(`<link rel="prefetch" as="${path.indexOf(".js") !== -1 ? "script" : path.indexOf(".css") !== -1 ? "style" : "image"}" href="${path}"/>`, false));
  }
  addDevScript() {
    if (common.commonContainer.buildOptions.commandName === "dev") {
      if (!this.htmlMeta.body)
        this.htmlMeta.body = { inlineScript: [] };
      this.htmlMeta.body.inlineScript.push({ name: "deps", code: `window.localStorage.setItem("tzV",${appContainer.versionId});` });
    }
  }
}

class HtmlPage extends Seo {
  constructor(route) {
    super(route);
    route.path = getUrl(route.path);
  }
  createPage(htmlMeta) {
    this.mergeHtmlMeta(htmlMeta);
    return this.buildHtml();
  }
  mergeHtmlMeta(htmlMeta) {
    if (htmlMeta)
      this.htmlMeta = vite.mergeConfig(this.htmlMeta, htmlMeta);
  }
  buildHtml() {
    this.buildElements();
    var html = common.commonContainer.buildOptions.commandName === "dev" || !common.commonContainer.tezConfig.build.minifyHtml ? indexTemplate(this) : htmlMinifier.minify(indexTemplate(this), {
      minifyJS: true,
      collapseWhitespace: true,
      removeComments: true,
      removeEmptyAttributes: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: true,
      removeStyleLinkTypeAttributes: true
    });
    if (common.commonContainer.buildOptions.commandName === "build") {
      let filePath = common.getPath([this.commonPath.rootPath, "dist", this.route.path], true);
      filePath = common.getPath([filePath, "index.html"]);
      common.writeFileSync(filePath, html, true);
      if (this.route.path === "/index")
        common.writeFileSync(common.getPath([this.commonPath.rootPath, "dist", "index.html"], false), html, true);
    }
    return html;
  }
}

let exampleOnResolvePlugin = {
  name: "example",
  setup(build2) {
    build2.onResolve({ filter: /.component.|.layout.|.page./ }, (args) => {
      if ([".component.", ".layout.", ".page."].filter((t) => args.path.indexOf(t) !== -1).length > 0)
        return { path: common.getPath([common.commonContainer.buildOptions.rootDir, "dist", args.path.indexOf("assets/") === -1 ? "assets" : "", args.path], false) };
      return { path: args.path };
    });
  }
};
class HtmlGen {
  constructor() {
    this.commonPathResolver = new common.CommonPathResolver();
    this.routes = common.commonContainer.getAppRoutes();
    this.depsConfig = depsContainer.getDeps();
    this.mainDependency = this.depsConfig.deps[this.commonPathResolver.tezJsPath];
    this.setExternals();
  }
  async build() {
    for (var route of this.routes) {
      let jsGenCode = new JsCodeGen(route);
      jsGenCode.gen();
      const path = getUrl(route.path);
      let page = {
        head: {
          inlineStyle: common.commonContainer.tezConfig.build.inLinCss ? this.getInlineCss(path) : new Array(),
          preloads: this.getPreloads(path),
          preFetch: this.getPreFetch(path)
        },
        body: {
          inlineScript: common.commonContainer.tezConfig.build.inLineJs ? await this.getInlineJs(path) : new Array(),
          script: !common.commonContainer.tezConfig.build.inLineJs ? [{ src: this.commonPathResolver.tezJsPath }] : [],
          style: common.commonContainer.tezConfig.build.bundleCss ? this.bundleCss(path) : []
        }
      };
      await this.minifyJs([`${path}/${this.commonPathResolver.preScriptName}`, `${path}/${this.commonPathResolver.postScriptName}`]);
      const htmlPage = new HtmlPage(route);
      htmlPage.createPage(page);
    }
    await this.writeTzWebWorker();
  }
  async writeTzWebWorker() {
    let jsPath = TZ_JS_PATH();
    if (this.commonPathResolver.pathExists(jsPath)) {
      const result = await esbuild.build({
        entryPoints: [jsPath],
        minify: true,
        write: false,
        sourcemap: false,
        format: "esm",
        outdir: "/bundle",
        logLevel: "silent"
      });
      for (const output of result.outputFiles)
        common.writeFileSync(this.commonPathResolver.tzJsPath, output.text, true);
    }
  }
  getPreFetch(path) {
    return [`${path}/${this.commonPathResolver.postScriptName}`];
  }
  getPreloads(path) {
    const depPath = this.commonPathResolver.tezJsPath;
    const prePath = `${path}/${this.commonPathResolver.preScriptName}`;
    let preloads = this.getPreloadTags(depPath);
    preloads.unshift({ path: "/tz.js" });
    if (common.commonContainer.tezConfig.client && common.commonContainer.tezConfig.client.loaderImage)
      preloads.push({ path: `${common.commonContainer.tezConfig.client.loaderImage}`, type: "image" });
    if (!common.commonContainer.tezConfig.build.inLineJs) {
      let preloadDeps = routeComponentWriter.getPreDeps(getUrl(path)).filter((path2) => path2.indexOf(".js") !== -1);
      preloadDeps.forEach((path2) => this.pushPreload(preloads, path2));
      preloads.push({ path: `${prePath}`, type: "module" });
      preloads.push({ path: `/${depPath}`, type: "module" });
    }
    return preloads;
  }
  getPreloadTags(path) {
    let preloads = new Array();
    if (this.depsConfig.deps[path]) {
      this.depsConfig.deps[path].js.forEach((item) => {
        let items = this.getPreloadTags(item);
        items.forEach((t) => this.pushPreload(preloads, `${t.path}`));
        this.pushPreload(preloads, `/${item}`);
      });
    }
    return preloads;
  }
  pushPreload(preloads, path) {
    if (preloads.filter((t) => t.path === path).length === 0) {
      preloads.push({ path, type: "module" });
    }
  }
  bundleCss(path) {
    let bundleCssPath = `${path}/bundle.css`;
    const cssReferences = this.getInlineCss(path, true);
    let code = [];
    if (cssReferences.length > 0) {
      cssReferences.forEach((cssItem) => code.push(cssItem.code));
      common.writeFileSync(common.getPath([this.commonPathResolver.distPath, bundleCssPath], false), code.join("\n"), true);
    }
    let cssRefs = new Array();
    cssRefs.push({ href: bundleCssPath });
    if (common.commonContainer.tezConfig.client.imports)
      cssRefs.push({ href: this.commonPathResolver.tezCSSPath });
    return cssRefs;
  }
  getInlineCss(path, isBundleCss = false) {
    let inlineCss = new Array();
    if (!isBundleCss)
      this.setInlineCss(this.mainDependency.css, inlineCss);
    const preComponents = routeComponentWriter.getRouteComponent(getUrl(path)).pre;
    for (const preComponent of preComponents) {
      const depPath = `assets/${preComponent}.${common.commonContainer.buildOptions.buildVersion}.js`;
      if (this.depsConfig.deps[depPath]) {
        this.setInlineCss(this.depsConfig.deps[depPath].css, inlineCss);
      }
    }
    return inlineCss;
  }
  setInlineCss(css, inlineCss) {
    for (const cssPath of css) {
      inlineCss.push({ name: cssPath, code: this.depsConfig.css[cssPath] });
    }
  }
  getJsRef(path) {
    return [{ src: `assets${path}/${this.commonPathResolver.preScriptName}` }, { src: this.commonPathResolver.tezJsPath }];
  }
  getCssRef(path) {
    const preCssPath = `assets${path}/pre.css`;
    let cssRefs = new Array();
    if (this.commonPathResolver.pathExists(common.getPath([this.commonPathResolver.distPath, preCssPath])))
      cssRefs.push({ href: preCssPath });
    cssRefs.push({ href: this.commonPathResolver.tezCSSPath });
    const depPath = `assets${path}/${this.commonPathResolver.preScriptName}`;
    if (this.depsConfig.deps[depPath])
      for (const cssPath of this.depsConfig.deps[depPath].css)
        cssRefs.push({ href: cssPath });
    return cssRefs;
  }
  async getInlineJs(path) {
    let preInlinePath = `${path}/pre.inline.js`;
    let inlineJsCode = await this.minifyJs([preInlinePath], true);
    let tezjsCode = common.readFileSync(common.getPath([this.commonPathResolver.distPath, this.commonPathResolver.tezJsPath]), true);
    inlineJsCode.push({ name: this.commonPathResolver.tezJsPath, code: this.resetImports(tezjsCode) });
    this.commonPathResolver.deleteFile(common.getPath([this.commonPathResolver.distPath, preInlinePath]));
    return inlineJsCode;
  }
  async minifyJs(jsPaths, isInline = false) {
    let inlineJs = new Array();
    for (const jsPath of jsPaths) {
      let fullPath = common.getPath([this.commonPathResolver.distPath, jsPath]);
      if (this.commonPathResolver.pathExists(fullPath)) {
        const result = await esbuild.build({
          entryPoints: [fullPath],
          plugins: [exampleOnResolvePlugin],
          bundle: isInline,
          allowOverwrite: true,
          minify: true,
          write: false,
          sourcemap: false,
          external: isInline ? this.externals : [],
          format: "esm",
          outfile: fullPath,
          logLevel: "silent"
        });
        for (const output of result.outputFiles) {
          let text = output.text;
          text = this.resetImports(text);
          if (isInline) {
            inlineJs.push({ name: jsPath, code: text });
          } else
            common.writeFileSync(fullPath, text, true);
        }
      }
    }
    return inlineJs;
  }
  resetImports(text) {
    for (let i = this.externals.length - 1; i >= 0; i--) {
      let externalJs = this.externals[i];
      if (text.indexOf(externalJs) > -1)
        text = text.replace(new RegExp(externalJs, "g"), `/assets/${externalJs.split("/").pop()}`);
    }
    return text;
  }
  setInlineJs(dependencyConfig, inlineJs) {
    for (const jsPath of dependencyConfig.js)
      inlineJs[jsPath] = this.depsConfig.css[jsPath];
  }
  setExternals() {
    this.externals = new Array();
    this.depsConfig.excludes.forEach((jsPath) => {
      let fileName = jsPath.replace("assets/", "");
      this.externals.push(`./${fileName}`);
      var path = "";
      this.externals.push(`./${fileName}`);
      for (var i = 0; i < this.depsConfig.highestPathDepth; i++) {
        path += "../";
        this.externals.push(`${path}${fileName}`);
      }
    });
  }
}

function tez() {
  return {
    name: "vite:tez",
    async closeBundle() {
      if (depsContainer.deps) {
        const htmlGen = new HtmlGen();
        await htmlGen.build();
        if (common.commonContainer.tezConfig.generate?.serviceWorker)
          generateSW();
      }
    },
    async buildStart() {
      await readConfig();
      if (common.commonContainer.buildOptions.commandName === "dev") {
        const pageCollection = new payload.PageCollection();
        await pageCollection.generate();
        common.commonContainer.getAppRoutes().forEach((route) => {
          const jsCodeGen = new JsCodeGen(route);
          jsCodeGen.gen();
        });
      }
    }
  };
}

class BundleModifier {
  constructor(bundle) {
    this.bundle = bundle;
    this.deps = {};
    this.excludes = new Array();
    this.css = {};
    this.highestPathDepth = 0;
    this.commonPath = new common.CommonPathResolver();
    this.globPath = `assets/glob.${common.commonContainer.buildOptions.buildVersion}.js`;
    this.depsPath = `assets/deps.${common.commonContainer.buildOptions.buildVersion}.js`;
    this.run();
  }
  overwrite() {
    for (const [path, dependencyConfig] of Object.entries(this.deps)) {
      for (const importString of dependencyConfig.unUsedImports)
        this.bundle[path].code = this.bundle[path].code.replace(importString, "");
    }
  }
  run() {
    this.addExcludeJsPaths();
    this.setDependency();
    this.removeBundleItem();
    depsContainer.setDeps({
      css: this.css,
      excludes: this.excludes,
      deps: this.deps,
      highestPathDepth: this.highestPathDepth
    });
  }
  setDependency() {
    for (const [path] of Object.entries(this.bundle)) {
      this.deps[path] = this.setDependencies(path);
    }
  }
  removeBundleItem() {
    delete this.bundle[this.depsPath];
    delete this.bundle[this.globPath];
  }
  addExcludeJsPaths() {
    this.setDependencies(this.commonPath.tezJsPath);
    if (this.deps[this.commonPath.tezJsPath])
      this.deps[this.commonPath.tezJsPath].js.forEach((x) => this.excludes.push(x));
  }
  setDependencies(path) {
    let deps = { js: new Array(), css: new Array(), unUsedImports: new Array(), preload: new Array() };
    if (this.bundle[path] && !this.deps[path]) {
      let outputOption = this.bundle[path];
      if (outputOption.importedBindings) {
        Object.keys(outputOption.importedBindings).forEach((key) => {
          if (outputOption.importedBindings[key].length >= 0) {
            if (outputOption.importedBindings[key].length > 0)
              deps.js.push(key);
            if (path === this.commonPath.tezJsPath) {
              deps.preload.push(key);
            }
            let dependency = this.setDependencies(key);
            dependency.css.forEach((item) => {
              if (deps.css.filter((x) => x === item).length === 0)
                deps.css.push(item);
            });
            if (outputOption.importedBindings[key].length > 0)
              dependency.js.forEach((item) => {
                if (deps.js.filter((x) => x === item).length === 0 && this.excludes.filter((x) => x === item).length === 0)
                  path === this.commonPath.tezJsPath ? this.excludes.push(item) : deps.js.push(item);
              });
          } else
            deps.unUsedImports.push(this.getImportString(path.split("/").length - 2, key));
        });
        for (let css of outputOption.viteMetadata.importedCss)
          deps.css.push(css);
      } else if (outputOption.name.endsWith(".css"))
        this.css[path] = outputOption.source;
      this.deps[path] = deps;
    }
    return this.deps[path];
  }
  getImportString(length, name) {
    if (length > this.highestPathDepth)
      this.highestPathDepth = length;
    name = name.replace("assets/", "");
    var path = length <= 0 ? "./" : "";
    for (var i = 0; i < length; i++)
      path += "../";
    return `import"${path}${name}";`;
  }
}

function tezGenBundle() {
  return {
    name: "vite:tez-gen-bundle",
    async generateBundle(_outputOptions, bundle) {
      var bundleModifier = new BundleModifier(bundle);
      bundleModifier.overwrite();
    }
  };
}

const VITE_SERVER_CONFIG = (config) => {
  const pathResolver = new common.CommonPathResolver();
  return {
    root: common.commonContainer.buildOptions.rootDir,
    logLevel: "info",
    envDir: "environments",
    resolve: {
      alias: [
        { find: "#client-env", replacement: `/node_modules/.cache/tez/client-env.ts` },
        { find: "#server-env", replacement: "/node_modules/.cache/tez/server-env.ts" },
        { find: "/tez.ts", replacement: pathResolver.tezTsPath },
        { find: "#add-lib", replacement: "/add-lib.ts" },
        { find: "/@", replacement: pathResolver.getPath([common.commonContainer.buildOptions.rootDir, common.commonContainer.tezConfig.sourceCodePath || BLANK]) },
        { find: "/tez", replacement: pathResolver.cachePath }
      ]
    },
    optimizeDeps: {
      entries: [
        pathResolver.tezTsPath
      ],
      include: ["vue"]
    },
    server: {
      middlewareMode: "ssr",
      watch: {
        usePolling: true,
        interval: 100
      }
    },
    build: {
      rollupOptions: {
        output: {
          entryFileNames: `assets/[name].${common.commonContainer.buildOptions.buildVersion}.js`,
          chunkFileNames: `assets/[name].${common.commonContainer.buildOptions.buildVersion}.js`,
          assetFileNames: `assets/[name].${common.commonContainer.buildOptions.buildVersion}.[ext]`
        }
      }
    },
    plugins: [vue__default(), tez(), tezGenBundle()]
  };
};

async function dev(config) {
  if (!common.commonContainer.buildOptions)
    common.commonContainer.buildOptions = { buildVersion: 0, mode: "", rootDir: process.cwd(), port: 3e3, commandName: "dev" };
  await readConfig();
  let additionalConfig = { root: common.commonContainer.buildOptions.rootDir };
  let viteConfig = vite.mergeConfig(VITE_SERVER_CONFIG(), additionalConfig);
  if (!config || config && !config.isSsr)
    delete viteConfig.server.middlewareMode;
  return viteConfig;
}

async function createViteServer() {
  let config = await dev({ isSsr: true });
  return await vite.createServer(config);
}

async function refreshData(url) {
  const pageCollection = new payload.PageCollection();
  await pageCollection.generate(url);
  let route = common.commonContainer.getAppRoutes().filter((route2) => route2.path === url)[0];
  if (route) {
    const jsCodeGen = new JsCodeGen(route);
    jsCodeGen.gen();
  }
}

class AllRouter {
  constructor(vite) {
    this.vite = vite;
    this.path = "*";
    this.router = express__namespace.Router();
    this.htmlCache = void 0;
    this.get = async (request, response) => {
      try {
        let htmlCache = void 0;
        await refreshData(request.url);
        const route = this.routes.filter((route2) => route2.path === request.url)[0] || { "name": "", "path": "/", "fPath": `${path__namespace.sep}index` };
        await appContainer.addOrUpdateTezTS(route);
        ++appContainer.versionId;
        var htmlPage = new HtmlPage(route);
        htmlCache = htmlPage.createPage();
        response.status(200).set({ "Content-Type": "text/html" }).end(htmlCache);
      } catch (e) {
        this.vite && this.vite.ssrFixStacktrace(e);
        console.log(e.stack);
        response.status(500).end(e.stack);
      }
      response.status(200).end();
    };
    this.initializeRoutes();
    this.routes = common.commonContainer.getAppRoutes();
  }
  initializeRoutes() {
    this.router.get(this.path, this.get);
  }
}

class AppRouter {
  constructor(routers, vite) {
    this.routers = routers;
    this.vite = vite;
    this.app = express__default();
  }
  async setup() {
    this.app.use(this.vite.middlewares);
    if (common.commonContainer.expressConfig && common.commonContainer.expressConfig.routes)
      this.app.use(common.commonContainer.expressConfig.routes);
    this.routers.forEach((router) => {
      this.app.use(router.router);
    });
    return { app: this.app, vite: this.vite };
  }
}

class RoutesRouter {
  constructor() {
    this.path = "/routes";
    this.router = express__namespace.Router();
    this.tezConfig = void 0;
    this.get = async (request, response) => {
      await refreshData(request.query?.path);
      response.status(200).end();
    };
    this.initializeRoutes();
    this.resolveConfig();
  }
  initializeRoutes() {
    this.router.get(this.path, this.get);
  }
  resolveConfig() {
    this.tezConfig = common.commonContainer.tezConfig;
  }
}

async function createTezServer() {
  let vite = await createViteServer();
  var appRouter = new AppRouter([new RoutesRouter(), new AllRouter(vite)], vite);
  return appRouter.setup();
}

function tzServer() {
  createTezServer().then(async ({ app }) => {
    const port = await getPortPlease.getPort({ ports: [common.commonContainer.buildOptions.port, ...Array(50).fill(3001).map((fillValue, index) => fillValue + index)] });
    app.listen(port, () => {
      console.log(`http://localhost:${port}`);
    });
  });
}

function globTemplate(pathResolver) {
  const globWriter = new payload.GlobWriter();
  let inputOptions = {};
  let componentsString = "";
  let layoutsString = "";
  let pagesString = "";
  globWriter.components.forEach((name) => {
    let fileName = `${payload.getFriendlyComponentName(name)}.component`;
    componentsString += `"${fileName}": import("/@/components/${name}.vue"),`;
    inputOptions[`${fileName.toLowerCase()}`] = common.getPath([pathResolver.componentsPath, `${name}.vue`], false);
  });
  globWriter.layouts.forEach((name) => {
    let fileName = `${payload.getFriendlyComponentName(name)}.layout`;
    layoutsString += `"${fileName}": import("/@/layouts/${name}.vue"),`;
    inputOptions[`${fileName.toLowerCase()}`] = common.getPath([pathResolver.layoutsPath, `${name}.vue`], false);
  });
  globWriter.pages.forEach((name) => {
    let fileName = `${payload.getFriendlyComponentName(name)}.page`;
    pagesString += `"${fileName}": import("/@/${name}.vue"),`;
    inputOptions[`${fileName.toLowerCase()}`] = common.getPath([pathResolver.sourceCodePath, `${name}.vue`], false);
  });
  return {
    template: `export const glob={
        components :{${componentsString}},
        layouts :{${layoutsString}},
        pages :{${pagesString}}
    };console.log(glob);`,
    inputOptions
  };
}
function writeDepsAndGlob(pathResolver) {
  const { template, inputOptions } = globTemplate(pathResolver);
  common.writeFileSync(pathResolver.getFilePath([pathResolver.cachePath], "glob.ts"), template, true);
  return inputOptions;
}

function addUpdateInputs(inputs, pathResolver) {
  const deps = {
    tez: pathResolver.tezTsPath,
    glob: common.getPath([pathResolver.cachePath, "glob.ts"], false)
  };
  return { ...inputs, ...deps };
}

async function build(config) {
  if (config)
    common.commonContainer.buildOptions = { buildVersion: common.convertDateToTicks(new Date()), mode: config.mode, rootDir: config.rootDir || process.cwd(), port: 3e3, commandName: "build" };
  await readConfig();
  appContainer.addOrUpdateTezTS();
  const pageCollection = new payload.PageCollection();
  await pageCollection.generate();
  let tezConfig = common.commonContainer.tezConfig;
  const pathResolver = new common.CommonPathResolver();
  const userConfig = tezConfig.viteOptions || {};
  let inputs = writeDepsAndGlob(pathResolver);
  const buildInput = {
    build: {
      rollupOptions: {
        input: addUpdateInputs(inputs, pathResolver)
      }
    }
  };
  let viteConfig = vite.mergeConfig(VITE_SERVER_CONFIG(), { ...userConfig, ...{ mode: "production" } });
  viteConfig = vite.mergeConfig(viteConfig, buildInput);
  if (!config || !config.configOnly)
    await vite.build(viteConfig);
  else
    return viteConfig;
}

function defineTezConfig(config) {
  return config;
}

exports.build = build;
exports.defineTezConfig = defineTezConfig;
exports.dev = dev;
exports.tez = tez;
exports.tzServer = tzServer;
